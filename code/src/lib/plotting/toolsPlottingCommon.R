# -----------------------------------------------------------------------------
#
# This script contain the axuliar functions that are common for all plotting libraries
#
# This include:
#
# ---- Get the default names for the plots
# ---- Get the default styles for the plots
# -----------------------------------------------------------------------------


# ------------------------------------------------
# GET DEFAULT PLOT VARIABLES
# ------------------------------------------------

    # Get default texts and color palettes for plots initialized to NULL inputs.
    #
    # Used in the plots type:
    #
    #     - "AbsBarplot"
    #     - "RelBarplot"
    #     - "LongAbsBarPlot"
    #     - "LongRelBarPlot"
    #
    # Input:
    #     -      (string) countingName: The name of the variable you are using to count.
    #     - List (string) myCategories: Each of the categories that you can find in that variable.
    #     - List (string) colorsVector: If NULL, it will return an automatic color for each category.
    #                                   If not NULL, it will return the same list.
    #     -      (string) plotTitle:    Your plot title, if NULL, it will return an autogenerated title.
    #     -      (string) plotSubtitle: Your plot subtitle, if NULL, it will return an autogenerated subtitle.
    #     -      (string) plotCaption:  Your plot caption, if NULL, it will return a generic default caption.
    #     -      (string) plotXLabel:   Your plot X label, if NULL, it will return a generic default X label. Otherwise, it return the same groupingName.
    #     -      (string) plotXLabel:   Your plot Y label, if NULL, it will return a generic default Y label. Otherwise.
    #     -      (string) plotType:     Select the type of plot that you have, the options are:
    #                                       - NULL (without quotes), select a generic default type. It works fine, but you will get weird naming.
    #                                       - "AbsBarplot",          select a barplot with absolute frequencies
    # Return:
    #     - list of colors, one for each category plotTitle, plotSubtitle, plotCaption, plotXLabel, plotYLabel)
    getCategoricalDefaults <- function(countingName, myCategories, colorsVector = NULL,
                                       plotTitle = NULL, plotSubtitle = NULL,
                                       plotCaption = NULL, plotXLabel = NULL,
                                       plotYLabel = NULL, plotType = NULL){
    
        # Get the number of categories form the categories vector
        nCategories = length(myCategories)
    
        # Prepare the defaults
        # ---- Strings for the plot
        # -------- Plot title
        if(is.null(plotTitle)){
      
            plotTitle    = "Default plot title"
            
            if(plotType == "AbsBarPlot")      plotTitle    = paste("Absolute Frequency for ", countingName, sep = "")
            if(plotType == "LongAbsBarPlot")  plotTitle    = paste("Absolute Frequency for ", countingName, sep = "")
            if(plotType == "RelBarPlot")      plotTitle    = paste("Relative Frequency for ", countingName, sep = "")
            if(plotType == "LongRelBarPlot")  plotTitle    = paste("Relative Frequency for ", countingName, sep = "")
      
            
            
        }
        # -------- Plot subtitle
        if(is.null(plotSubtitle)){
      
            plotSubtitle = ""
      
        }
        # -------- Plot caption
        if(is.null(plotCaption)){
      
            plotCaption = ""
      
        }
        # -------- Plot X axys
        if(is.null(plotXLabel)){
      
            groupingName = "X"
            plotXLabel = groupingName
      
        }
        # -------- Plot Y axys
        if(is.null(plotYLabel)){
      
            plotYLabel = "Y"
      
            if(plotType == "AbsBarplot")      plotYLabel = "Absolute Frequency"
            if(plotType == "LongBarplot")     plotYLabel = "Absolute Frequency"
            if(plotType == "RelBarplot")      plotYLabel = "Relative Frequency"
            if(plotType == "LongRelBarplot")  plotYLabel = "Relative Frequency"

        }
        # ---- Color scheme
        print(is.null(colorsVector))
        print(is.na(colorsVector))
        
        # R is a shitty language.
        # A variable = NA , then is.na() = TRUE
        # A vector = 2 3 4 , then is.na() = FALSE FALSE FALSE
        
        if(is.null(colorsVector)){

        	myPalette    = colorRampPalette(brewer.pal(5, "Spectral"))
            colorsVector = myPalette(nCategories)        	
        	        	
        }
        else{
        
        	if(length(colorsVector)==1){
        		
	        	if(is.na(colorsVector)){
	      
	            	myPalette    = colorRampPalette(brewer.pal(5, "Spectral"))
	            	colorsVector = myPalette(nCategories)
	      
	        	}        		
        		
        	}
        		
        }

        toReturn = c(list(colorsVector),
                     plotTitle,
                     plotSubtitle,
                     plotCaption,
                     plotXLabel,
                     plotYLabel)
    
        return(toReturn)
    
    }
  
    # Get default text and color palettes for plots inits to NULL inputs
    # This version is for when you are grouping two categories together
    #
    # Variable A is display in the X axys
    # Variable B is display in the Y axys
    #
    # Used in the plots type:
    #
    #     - "CombinedLongAbsBarPlot"
    #     - "CombinedLongRelBarPlot"
    #     - "CombinedAbsBarPlot"
    #     - "CombinedRelBarPlot"
    #
    getBiCategoricalDefaults <- function(groupingNameA, myCategoriesA, 
                                         groupingNameB, myCategoriesB, 
                                         colorsVector = NULL,
                                         plotTitle = NULL, plotSubtitle = NULL,
                                         plotCaption = NULL, plotXLabel = NULL,
                                         plotYLabel = NULL, plotType = NULL){
    
        # Get the number of categories form the categories vector
        nCategoriesA  = length(myCategoriesA)
        nCategoriesB  = length(myCategoriesB)
    
        # Prepare the defaults
        # ---- Strings for the plot
        # -------- Plot title
        if(is.null(plotTitle)){
      
            if(is.null(plotType))                    plotTitle    = "Default plot title"
            if(plotType == "CombinedRelBarPlot")     plotTitle    = paste("Relative Frequency of ", groupingNameA, sep = "")
            if(plotType == "CombinedAbsBarPlot")     plotTitle    = paste("Abs Frequency of ",      groupingNameA, sep = "")
            if(plotType == "CombinedLongRelBarPlot") plotTitle    = paste("Relative Frequency of ", groupingNameA, sep = "")
            if(plotType == "CombinedLongAbsBarPlot") plotTitle    = paste("Abs Frequency of ",      groupingNameA, sep = "")            
      
        }
        # -------- Plot subtitle
        if(is.null(plotSubtitle)){
      
            plotSubtitle = ""
            if(plotType == "CombinedRelBarPlot")     plotSubtitle = paste("Grouped by ", groupingNameB, sep = "")
            if(plotType == "CombinedAbsBarPlot")     plotSubtitle = paste("Grouped by ", groupingNameB, sep = "")
            if(plotType == "CombinedLongRelBarPlot") plotSubtitle = paste("Grouped by ", groupingNameB, sep = "")
            if(plotType == "CombinedLongAbsBarPlot") plotSubtitle = paste("Grouped by ", groupingNameB, sep = "")            
      
        }
        # -------- Plot caption
        if(is.null(plotCaption)){
      
            plotCaption = ""
      
        }
        # -------- Plot X axys
        if(is.null(plotXLabel)){
      
            plotXLabel = groupingNameA
      
        }
        # -------- Plot Y axys
        if(is.null(plotYLabel)){
      
            plotYLabel = "Y"
            if(plotType == "CombinedRelBarPlot")     plotYLabel = "Relative frequency"
            if(plotType == "CombinedRelAbsPlot")     plotYLabel = "Absolute frequency"
            if(plotType == "CombinedLongRelBarPlot") plotYLabel = "Relative frequency"
            if(plotType == "CombinedLongRelAbsPlot") plotYLabel = "Absolute frequency"            
      
        }
        # ---- Color scheme
        if(is.null(colorsVector) || is.na(colorsVector)){
      
            myPalette    = colorRampPalette(brewer.pal(11, "Spectral"))
            colorsVector = myPalette(nCategoriesB)
      
        }
    
    
        toReturn = c(list(colorsVector), plotTitle, plotSubtitle, plotCaption, plotXLabel, plotYLabel) # R is a stupid language. FUCK YOU!. A vector of 6 things, should return 6 things even if one of the things is a NULL object. Do you heard me you piece of shit!?? You don't get to decide what is in the vector and what is not.

        return(toReturn)
    
    }
  
    # Get default text and color palettes for plots inits to NULL inputs
    # This version is for when you are not grouping an just have one numerical variable
    #
    # Used in the plots type:
    #
    #     - "Boxplots"
    #     - "Density"
    #     - "Histogram"
    #     - "QQ"
    #
    # You have the option to do Categorical Boxplots somewhere else
    getNumericalDefaults <- function(numericalName,
                                     colorsVector = NULL,
                                     plotTitle = NULL, plotSubtitle = NULL,
                                     plotCaption = NULL, plotXLabel = NULL,
                                     plotYLabel = NULL, fileType = NULL){
    
        # Prepare the defaults

        # ---- Strings for the plot
        # -------- Plot title
        if(is.null(plotTitle)){
      
            if(is.null(fileType))             plotTitle    = "Default plot title"
            if(fileType == "Boxplot")         plotTitle    = paste("Boxplot for ",              numericalName, sep = "")
            if(fileType == "Density")         plotTitle    = paste("Density distribution for ", numericalName, sep = "")
            if(fileType == "Histogram")       plotTitle    = paste("Histogram for ",            numericalName, sep = "")
            if(fileType == "QQ")              plotTitle    = paste("QQ-plot for  ",             numericalName, sep = "")
      
        }
        # -------- Plot subtitle
        if(is.null(plotSubtitle)){
      
            plotSubtitle = ""
      
        }
        # -------- Plot caption
        if(is.null(plotCaption)){
      
            plotCaption = ""
      
        }
        # -------- Plot X axys
        if(is.null(plotXLabel)){
      
            if(is.null(fileType))             plotXLabel = ""
            if(fileType == "Boxplot")         plotXLabel = numericalName
            if(fileType == "Density")         plotXLabel = numericalName
            if(fileType == "Histogram")       plotXLabel = numericalName
            if(fileType == "QQ")              plotXLabel = paste("Theoretical quantiles for  ", numericalName, sep = "")
      
        }
        # -------- Plot Y axys
        if(is.null(plotYLabel)){
      
            if(is.null(fileType))             plotYLabel = ""
            if(fileType == "Boxplot")         plotYLabel = "Absolute Frequency"
            if(fileType == "Density")         plotYLabel = "Relative Frequency"
            if(fileType == "Histogram")       plotYLabel = "Absolute Frequency"
            if(fileType == "QQ")              plotYLabel = paste("Actual quantiles for  ", numericalName, sep = "")

        }
    
        # ---- Color scheme
        if(is.null(colorsVector) || is.na(colorsVector)){
      
            #myPalette    = colorRampPalette(brewer.pal(5, "Spectral"))
            #colorsVector = myPalette(1)
      
            # Default to black
            colorsVector = "#000000"
      
        }
    
        toReturn = c(list(colorsVector), plotTitle, plotSubtitle, plotCaption, plotXLabel, plotYLabel)
    
        return(toReturn)
    
    }
  
    
    # Get default text and color palettes for plots inits to NULL inputs
    # This version is for when you are not grouping and have two numerical variable
    #
    # Used in the plots type:
    #
    #     - "Scatterplot"
    #     - "DateScatterplot"    
    #
    getBiNumericalDefaults <- function(numericalNameA, numericalNameB, 
                                       colorsVector = NULL,
                                       plotTitle = NULL, plotSubtitle = NULL,
                                       plotCaption = NULL, plotXLabel = NULL,
                                       plotYLabel = NULL,  fileType = NULL){
    
        # Prepare the defaults
        # ---- Strings for the plot
        # -------- Plot title
        if(is.null(plotTitle)){
      
            if(is.null(fileType))             plotTitle    = "Default plot title"
            if(fileType == "Scatterplot")     plotTitle    = paste("Scatterplot for ",      numericalNameA, " and ", numericalNameB,  sep = "")
            if(fileType == "DateScatterplot") plotTitle    = paste("Date Scatterplot for ", numericalNameA, " and ", numericalNameB,  sep = "")
      
        }
        # -------- Plot subtitle
        if(is.null(plotSubtitle)){
      
            plotSubtitle = ""
      
        }
        # -------- Plot caption
        if(is.null(plotCaption)){
      
            plotCaption = ""
      
        }
        # -------- Plot X axys
        if(is.null(plotXLabel)){
        
            if(is.null(fileType))             plotXLabel = ""
            if(fileType == "Scatterplot")     plotXLabel = numericalNameA
            if(fileType == "DateScatterplot") plotXLabel = numericalNameA
        }
        # -------- Plot Y axys
        if(is.null(plotYLabel)){
        
            if(is.null(fileType))             plotYLabel = ""
            if(fileType == "Scatterplot")     plotYLabel = numericalNameB
            if(fileType == "DateScatterplot") plotYLabel = numericalNameB            
        }
        # ---- Color scheme
        if(is.null(colorsVector) || is.na(colorsVector)){

            myPalette    = colorRampPalette(brewer.pal(5, "Spectral"))
            colorsVector = myPalette(1)

        }
    
    
        toReturn = c(list(colorsVector), plotTitle, plotSubtitle, plotCaption, plotXLabel, plotYLabel)
    
        return(toReturn)
    
    }
    
    
    # Get default text and color palettes for plots inits to NULL inputs
    # This version is for when you are grouping and have two numerical variable
    #
    # Used in the plots type:
    #
    #     - "ScatterplotCategorical"
    #     - "DateScatterplotCategorical"    
    #
    getBiNumericalCategoricalDefaults <- function(numericalNameA, numericalNameB, groupingNameA, myCategoriesA,
                                                  colorsVector = NULL,
                                                  plotTitle = NULL, plotSubtitle = NULL,
                                                  plotCaption = NULL, plotXLabel = NULL,
                                                  plotYLabel = NULL,  fileType = NULL){
    
        
        # Get the number of categories form the categories vector
        nCategoriesA  = length(myCategoriesA)
        
        # Prepare the defaults
        # ---- Strings for the plot
        # -------- Plot title
        if(is.null(plotTitle)){
      
            if(is.null(fileType))                        plotTitle    = "Default plot title"
            if(fileType == "ScatterplotCategorical")     plotTitle    = paste("Scatterplot for ",      numericalNameA, " and ", numericalNameB,  "grouped by", groupingName, sep = "")
            if(fileType == "DateScatterplotCategorical") plotTitle    = paste("Date Scatterplot for ", numericalNameA, " and ", numericalNameB,  "grouped by", groupingName, sep = "")
      
        }
        # -------- Plot subtitle
        if(is.null(plotSubtitle)){
      
            plotSubtitle = ""
      
        }
        # -------- Plot caption
        if(is.null(plotCaption)){
      
            plotCaption = ""
      
        }
        # -------- Plot X axys
        if(is.null(plotXLabel)){
        
            if(is.null(fileType))                        plotXLabel = ""
            if(fileType == "ScatterplotCategorical")     plotXLabel = numericalNameA
            if(fileType == "DateScatterplotCategorical") plotXLabel = numericalNameA            
        }
        # -------- Plot Y axys
        if(is.null(plotYLabel)){
        
            if(is.null(fileType))                        plotYLabel = ""
            if(fileType == "ScatterplotCategorical")     plotYLabel = numericalNameB
            if(fileType == "DateScatterplotCategorical") plotYLabel = numericalNameB            
        }

        # ---- Color scheme
        if(is.null(colorsVector) || is.na(colorsVector)){
      
            myPalette    = colorRampPalette(brewer.pal(11, "Spectral"))
            colorsVector = myPalette(nCategoriesA)
            print(colorsVector)
        }    
        
        
        toReturn = c(list(colorsVector), plotTitle, plotSubtitle, plotCaption, plotXLabel, plotYLabel)
    
        return(toReturn)
    
    }    
  
    # Get default text and color palettes for plots inits to NULL inputs
    # This version is for when you are grouping a categories and a numerical
    #
    #      Categorical Boxplots   (one numerical variable Y-axis, each boxplot is a category X-axys)
    #      Categorical Histograms (one numerical variable Y-axis, each bin is divided in a category X-axys)
    #      Categorical Density    (same as histograms, but continous without bins)
    #      BMIPlots               (same as density, but already setup for BMI variables)
    
    getCategoricalNumericalDefaults <- function(groupingName, myCategories,
                                                numericalName,
                                                colorsVector = NULL,
                                                plotTitle = NULL, plotSubtitle = NULL,
                                                plotCaption = NULL, plotXLabel = NULL,
                                                plotYLabel = NULL, fileType = NULL){
    
        # Get the number of categories form the categories vector
        nCategories = length(myCategories)
    
        # Prepare the defaults
        # ---- Strings for the plot
        # -------- Plot title
        if(is.null(plotTitle)){
      
            if(is.null(fileType))                  plotTitle = "Default plot title"
            if(fileType == "BMIPlot")              plotTitle = paste("BMI for ",                  groupingName,  sep = "")
            if(fileType == "CategoricalBoxplot")   plotTitle = paste("Boxplot for ",              numericalName, sep = "")
            if(fileType == "CategoricalHistogram") plotTitle = paste("Histogram for ",            numericalName, sep = "")
            if(fileType == "CategoricalDensity")   plotTitle = paste("Density distribution for ", numericalName, sep = "")
            if(fileType == "pValuesHeatmap")       plotTitle = paste("P-Values heatmap for ",     groupingName,  sep = "")
      
      
        }
        # -------- Plot subtitle
        if(is.null(plotSubtitle)){
      
            if(is.null(fileType))                  plotSubtitle = ""
            if(fileType == "BMIPlot")              plotSubtitle = paste("Grouped by ", groupingName, sep = "")
            if(fileType == "CategoricalBoxplot")   plotSubtitle = paste("Grouped by ", groupingName, sep = "")
            if(fileType == "CategoricalHistogram") plotSubtitle = paste("Grouped by ", groupingName, sep = "")
            if(fileType == "CategoricalDensity")   plotSubtitle = paste("Grouped by ", groupingName, sep = "")
            
            # p-Values Heatmap nothing
      
      
        }
        # -------- Plot caption
        if(is.null(plotCaption)){
      
            plotCaption = ""
      
        }
        # -------- Plot X axys
        if(is.null(plotXLabel)){
      
            plotXLabel = groupingName
      
            if(is.null(fileType))                  plotXLabel = "X"
            if(fileType == "BMIPlot")              plotXLabel = "BMI"
            if(fileType == "CategoricalBoxplot")   plotXLabel = groupingName
            if(fileType == "CategoricalHistogram") plotXLabel = groupingName
            if(fileType == "CategoricalDensity")   plotXLabel = groupingName
            if(fileType == "pValuesHeatmap")       plotXLabel = groupingName
      
        }
        # -------- Plot Y axys
        if(is.null(plotYLabel)){
      
            if(is.null(fileType))                  plotYLabel = "Y"
            if(fileType == "BMIPlot")              plotYLabel = "Relative Frequency"
            if(fileType == "CategoricalBoxplot")   plotYLabel = numericalName
            if(fileType == "CategoricalHistogram") plotYLabel = "Absolute Frequency"
            if(fileType == "CategoricalDensity")   plotYLabel = "Relative Frequency"
            if(fileType == "pValuesHeatmap")       plotYLabel = groupingName
      
        }
        # ---- Color scheme
        if(is.null(colorsVector) || is.na(colorsVector)){
      
            myPalette    = colorRampPalette(brewer.pal(5, "Spectral"))
            colorsVector = myPalette(nCategories)
      
        }

        toReturn = c(list(colorsVector), plotTitle, plotSubtitle, plotCaption, plotXLabel, plotYLabel)
    
        return(toReturn)
    
    }
  
    # (I HAVE NO IDEA WHY WE ARE USING THIS???)
    # Get default text and color palettes for plots inits to NULL inputs
    # This version is for when you are grouping 2 categories and one numerical
    getBiCategoricalNumericalDefaults <- function(groupingName, myGroupCategories,
                                                  fillingName, myFillCategories,
                                                  numericalName,
                                                  colorsVector = NULL,
                                                  plotTitle = NULL, plotSubtitle = NULL,
                                                  plotCaption = NULL, plotXLabel = NULL,
                                                  plotYLabel = NULL, fileType = NULL){
    
        # Get the number of categories form the categories vector
        nGroupCategories = length(myGroupCategories)
        nFillCategories  = length(myFillCategories)
    
        # Prepare the defaults
        # ---- Strings for the plot
        # -------- Plot title
        if(is.null(plotTitle)){
      
            if(is.null(fileType))                        plotTitle = "Default plot title"
            if(fileType == "DoubleCategoricalBoxplot")   plotTitle = paste0("Boxplots for ", fillingName, " grouped by ", groupingName)

        }
        # -------- Plot subtitle
        if(is.null(plotSubtitle)){
      
            if(is.null(fileType))                        plotSubtitle = ""
            if(fileType == "DoubleCategoricalBoxplot")   plotSubtitle = ""

        }
        # -------- Plot caption
        if(is.null(plotCaption)){
      
            plotCaption = ""
      
        }
        # -------- Plot X axys
        if(is.null(plotXLabel)){
      
            plotXLabel = groupingName
      
            if(is.null(fileType))                      plotXLabel = "X"
            if(fileType == "DoubleCategoricalBoxplot") plotXLabel = groupingName
      
        }
        # -------- Plot Y axys
        if(is.null(plotYLabel)){
      
            if(is.null(fileType))                      plotYLabel = "Y"
            if(fileType == "DoubleCategoricalBoxplot") plotYLabel = numericalName

        }
        # ---- Color scheme
        if(is.null(colorsVector) || is.na(colorsVector)){
      
            myPalette    = colorRampPalette(brewer.pal(5, "Spectral"))
            colorsVector = myPalette(nFillCategories)
      
        }

        toReturn = c(list(colorsVector), plotTitle, plotSubtitle, plotCaption, plotXLabel, plotYLabel)
    
        return(toReturn)
    
    }
  
  
  
  # TODO REVISE THIS
  # Get the defaults text and color for the network plots
  getCategoricalNetworkDefaults   <- function(highlightName = NULL, rimName = NULL,
                                              nCategoriesHighlight = NULL, nCategoriesRim = NULL,
                                              colorsVectorHighlight = NULL, colorVectorRim = NULL,
                                              plotTitle = NULL, plotSubtitle = NULL,
                                              plotCaption = NULL, plotXLabel = NULL,
                                              plotYLabel = NULL, fileType = NULL){

    # Prepare the defaults
    # ---- Strings for the plot
    # -------- Plot title
    if(is.null(plotTitle)){
     
	      if(is.null(highlightName)){
	    	    plotTitle = ""
	      }
	      else{
	        	plotTitle = paste0("Plot of a network using ", highlightName)  
	      }
    	
    }
    # -------- Plot subtitle
    if(is.null(plotSubtitle)){

	      if(is.null(rimName)){
		      plotSubtitle = ""
	      }
	      else{
		       plotSubtitle = paste0("Rim hightlight with ", rimName)
	      }

    }
    # -------- Plot caption
    if(is.null(plotCaption)){
      
    	plotCaption = ""
      
    }
    # -------- Plot X axys
    if(is.null(plotXLabel)){
      
    	 plotXLabel = ""
      
    }
    # -------- Plot Y axys
    if(is.null(plotYLabel)){
      
    	 plotYLabel = ""
      
    }
    
    # ---- Color scheme for both variables
    if(is.null(colorsVectorHighlight) || is.na(colorsVectorHighlight) ){
		print(colorsVectorHighlight)
    	myPalette             = colorRampPalette(brewer.pal(5, "Spectral"))
    	colorsVectorHighlight = myPalette(nCategoriesHighlight)
      
    }
    if(is.null(colorVectorRim) || is.na(colorVectorRim)){
      
    	myPalette             = colorRampPalette(brewer.pal(5, "Spectral"))
    	colorVectorRim        = myPalette(nCategoriesRim)
      
    }
    
    toReturn = c(list(colorsVectorHighlight), list(colorVectorRim), plotTitle, plotSubtitle, plotCaption, plotXLabel, plotYLabel)

    return(toReturn)
    
  }
  
  
    # Get parameters for the theme depending on your theme
    # - white   / (default)
    # - no-grid / same as white, without axys, lines, or numbers in the axys
    # - simple  / same as white without legend
    # - blank   / without anything
    # - ggplot  / Default ggplot2 theme
    getThemeParameters <- function(themeName){
    
        # Init the default theme (white)
        myTheme = list(rep(NA,10))
    
        myTheme[[1]] = element_blank()                  # 1: Background color
        myTheme[[2]] = element_line(colour = "black")   # 2: Axys X and Y Line color
        myTheme[[3]] = element_line(colour = "grey70")  # 3: Axys Y , major breaks
        myTheme[[4]] = element_blank()                  # 4: Axys X , major breaks
        myTheme[[5]] = "right"                          # 5: Legend
        myTheme[[6]] = element_line(size = 3)           # 6: Ticks in both X and Y
        myTheme[[7]] = element_text()                   # 7: Numbers in the X axys
        myTheme[[8]] = element_text()                   # 8: Numbers in the Y axys
        myTheme[[9]] = element_blank()                  # 9: Border around the inner panel
        
        # If you didn't gave a NULL theme
        if(!is.null(themeName)){
      
            if(themeName == "white"){ # White theme is the default too
                myTheme[[1]] = element_blank()
                myTheme[[2]] = element_line(colour = "black")
                myTheme[[3]] = element_line(colour = "grey70")
                myTheme[[4]] = element_blank()
                myTheme[[5]] = "right"
            }
      
            if(themeName == "no-grid"){ # Bare theme with legend only
                myTheme[[1]] = element_blank()
                myTheme[[2]] = element_blank()
                myTheme[[3]] = element_blank()
                myTheme[[4]] = element_blank()
                myTheme[[5]] = "right"
                myTheme[[6]] = element_blank() # Ticks in both X and Y
                myTheme[[7]] = element_blank() # Numbers in the X axys
                myTheme[[8]] = element_blank() # Numbers in the Y axys
            }

            if(themeName == "blank"){
                myTheme[[1]] = element_rect(fill='transparent')
                myTheme[[2]] = element_blank()
                myTheme[[3]] = element_blank()
                myTheme[[4]] = element_blank()
                myTheme[[5]] = "none"
                myTheme[[6]] = element_blank() 
                myTheme[[7]] = element_blank()
                myTheme[[8]] = element_blank()
            }
      
            if(themeName == "ggplot"){
                myTheme[[1]] = element_rect(colour = "grey")   # 1: Background color
                myTheme[[2]] = element_blank()                 # 2: Axys X and Y Line color
                myTheme[[3]] = element_line(colour = "white")  # 3: Axys Y , major breaks
                myTheme[[4]] = element_line(colour = "white")  # 4: Axys X , major breaks
                myTheme[[5]] = "right"                         # 5: Legend
            }
      
            if(themeName == "simple"){
                myTheme[[1]] = element_blank()
                myTheme[[2]] = element_line(colour = "black")
                myTheme[[3]] = element_line(colour = "grey70")
                myTheme[[4]] = element_blank()
                myTheme[[5]] = "none"
            }
            
            if(themeName == "regression"){ # White plus soft grey break lines
                myTheme[[1]] = element_blank()
                myTheme[[2]] = element_line(colour = "black")
                myTheme[[3]] = element_line(colour = "#ebebeb")
                myTheme[[4]] = element_line(colour = "#ebebeb")
                myTheme[[5]] = "right"
                myTheme[[6]] = element_line(size = 3)           # 6: Ticks in both X and Y
                myTheme[[7]] = element_text()                   # 7: Numbers in the X axys
                myTheme[[8]] = element_text()                   # 8: Numbers in the Y axys
                myTheme[[9]] = element_rect(color = "grey10",    # 9: Border around the inner panel
                                            fill = NA,
                                            size = 1)                   
                                
                
            }            
      
        }
    
        return(myTheme)
    
    }
  
 

# ------------------------------------------------
# TOOLS FOR PLOTTING
# ------------------------------------------------
  
  
  # Create a layout in the shape of circles, where each circle is a modality of a
  # categorical variable. This type of layout is not implemented in the igraph
  # package, so I did this myself.
  #
  # The function will create a summary of the categorical variable. This summary
  # is later returned to the user. The circles are not sorted in any particular
  # order and it will respect the factor order of that category. You can later on
  # check the order by which the circles were drawn by just reading this summary
  # which is returned by the function.
  #
  # The first circle is drawn at 0 radians, and goes counterclock wise and
  # equally spaced from each other until you reach all the categories.
  #
  # edgesDF: The dataframe with the edges
  #
  # nodesDF: The dataframe with the nodes
  #
  # categoricalIndex: Index of the column nodesDF with the categorical variable by
  #                   which you want to create the layout.
  #
  # directedGraph:    Whether or not you want the edges to have a pointing arrow
  #                   with the directed information. Default is FALSE.
  #
  # Return the layout [1]
  # And the summary so you can know the categories order [2]
  createCategoricalLayout <- function(edgesDF, nodesDF, categoricalIndex, manualCentroids = NULL, directedGraph = FALSE){
    
      # Prepare a random layout so we have the datastructure ready
      {
          myGraph = graph_from_data_frame(edgesDF, vertices = nodesDF, directed = directedGraph)
    	  myConstantLayoutA = create_layout(graph = myGraph, layout = "mds")
          myConstantLayoutB = subset(myConstantLayoutA, name %in% myConstantLayoutA$name, x:y)    
      }
    
      # Get all the categories stats
      {
    	  myCurrentSummary        = summarizeCategorical(nodesDF, categoricalIndex, sorted="none")
    	  uniqueCategories        = myCurrentSummary[,1]
    	  totalUniques            = length(uniqueCategories)          
      }
    
      # Prepare the vectors where we are going to put the first centers (outer circle)
      {
    	  centroidsX     = rep(0,totalUniques)
          centroidsY     = rep(0,totalUniques)
	      radianDistance = 0
	      radianChunks   = 0
	      
	      if(totalUniques>1){
	      	
	          radianDistance = (2*pi)/totalUniques
	          radianChunks   = seq(0,(totalUniques-1)) * radianDistance
	          
	      }
	      
	      minX  = min(myConstantLayoutB$x)
	      maxX  = max(myConstantLayoutB$x)
	      minY  = min(myConstantLayoutB$y)
	      maxY  = max(myConstantLayoutB$y)
	      centerX = (maxX + minX)/2
	      centerY = (maxY + minY)/2
	      diffX   = maxX - minX
	      firstCircleRadious  = diffX/4               # Radious distance is arbitrary, it just looks nice with /4
	      
	      centroidsX = centerX + cos(radianChunks) * firstCircleRadious
	      centroidsY = centerY + sin(radianChunks) * firstCircleRadious
      }
  	
  	  # If you have a manual list of centroids, use that instead
  	  if( !is.null(manualCentroids) ){
  	  	
  	      if(length(manualCentroids) == totalUniques){
  	      	
  	          for(i in 1:totalUniques){
  	      	
  	              centroidsX[i] = manualCentroids[[i]][1] * (maxX - minX)
  	              centroidsY[i] = manualCentroids[[i]][2] * (maxY - minY)
  	          		
  	          }
  	      	
  	      }
  	  	  
  	  	  else{
  	  	   
  	  	      print("The provided list of centroid is of different dimmensions as the number of categories, I'm going to use the default layout instead")
  	  	
  	  	   		
  	  	  }
  	  	
  	  	
  	  }
  	
    
    # For each category, find the coordinates for each node
    {
      # -- The coordinates goes into this matrixes
      coordinatesX = matrix(NA, nrow = totalUniques, ncol = max(myCurrentSummary[,2]))
      coordinatesY = matrix(NA, nrow = totalUniques, ncol = max(myCurrentSummary[,2]))
      # -- The radious of each individual circle
      secondCircleRadious  = firstCircleRadious
      if(totalUniques>1) secondCircleRadious = sqrt((centroidsX[1] - centroidsX[2])^2  +
                                                    (centroidsY[1] - centroidsY[2])^2 )/4 # /1 overlap
      # / 2 touch each other
      # / 4 there is a space in between 
      
      # -- Fill each row
      for (i in 1:totalUniques) {
        
        # Get how many are in this particular modality
        totalCurrentModality = myCurrentSummary[i,2]
        
        # Create the two vectors where you are going to write this
        minicentroidsX     = rep(0,totalCurrentModality)
        minicentroidsY     = rep(0,totalCurrentModality)
        radianDistance     = 0
        radianChunks       = 0
        if(totalCurrentModality>1){
          radianDistance = (2*pi)/totalCurrentModality
          radianChunks   = seq(0,(totalCurrentModality-1)) * radianDistance
        }
        
        minicentroidsX = centroidsX[i] + cos(radianChunks) * secondCircleRadious
        minicentroidsY = centroidsY[i] + sin(radianChunks) * secondCircleRadious
        
        # Do this one by one , since R doesn't want to replace the whole row ¬¬
        for(j in 1:totalCurrentModality){
          
          coordinatesX[i,j] = minicentroidsX[j]
          coordinatesY[i,j] = minicentroidsY[j]
          
        }
        
      }      
    }
    
    # Change the x,y coordinate of each node in the layout
    {
      myIndexes = rep(1,totalUniques)
      
      for (i in 1:nrow(myConstantLayoutB)) {
        
        # Get the category
        currentCategory = nodesDF[i,categoricalIndex]
        
        # Grab the index of this category      
        currentIndex = which(currentCategory == uniqueCategories)
        
        # Assign that corresponding coordinates
        myConstantLayoutB$x[i] = coordinatesX[currentIndex, myIndexes[currentIndex]]
        myConstantLayoutB$y[i] = coordinatesY[currentIndex, myIndexes[currentIndex]]
        
        # Increase the index for that modality
        myIndexes[currentIndex] = myIndexes[currentIndex] + 1
        
        
      }      
    }
    
    myReturn      = vector("list", length = 2)
    myReturn[[1]] = myConstantLayoutB
    myReturn[[2]] = myCurrentSummary
    
    return(myReturn)
    
  }

